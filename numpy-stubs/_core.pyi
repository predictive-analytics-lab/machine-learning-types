"""
Numpy's mypy stub. Only type declarations for ndarray, the scalar hierarchy and array creation
methods are provided.
"""

from typing import (
    Any,
    Callable,
    Dict,
    Generic,
    Iterator,
    IO,
    List,
    Optional,
    Sequence,
    Tuple,
    Type,
    TypeVar,
    Union,
    overload,
)
from pathlib import Path
import builtins

class dtype: ...
class bool_(dtype): ...
class number(dtype): ...
class floating(number, float): ...
class float32(floating): ...
class float64(floating): ...
class integer(number, int): ...
class int16(integer): ...
class int32(integer): ...
class int64(integer): ...

_dtype = dtype

_ShapeType = Union[int, Tuple[int, ...], List[int]]
_AxesType = Union[int, Tuple[int, ...], List[int]]
_OrderType = Union[str, Sequence[str]]
_DtypeType = Union[dtype, type]
newaxis: None = None

# all the python types that an ndarray can have
_AnyNum = Union[int, float, bool]
# generic types that are only allowed to take on dtype values
_DType = TypeVar('_DType', bound=_dtype)
_DType2 = TypeVar('_DType2', bound=_dtype)
_Float = TypeVar('_Float', bound=floating)
_Int = TypeVar('_Int', bound=integer)

_T = TypeVar('_T')
_NestedList = Union[List[_T], List[List[_T]], List[List[List[_T]]], List[List[List[List[_T]]]]]

class ndarray(Generic[_DType]):
    """
    "array-like" interface that both numpy.ndarray and all scalars (descendants of numpy.generic)
    implement this interface.
    """

    #
    # Array-like structures attributes
    #
    dtype: _dtype
    size: int
    ndim: int
    shape: Tuple[int, ...]

    #
    # Array-like methods
    #
    def __init__(
        self,
        shape: Tuple[int, ...],
        dtype: Optional[_DtypeType] = ...,
        buffer: Optional[Any] = ...,
        offset: Optional[int] = ...,
        strides: Optional[Tuple[int, ...]] = ...,
        order: Optional[str] = ...,
    ) -> None: ...
    def all(self, axis: Optional[_AxesType] = ..., keepdims: bool = ...) -> ndarray[_DType]: ...
    def any(self, axis: Optional[_AxesType] = ..., keepdims: bool = ...) -> ndarray[_DType]: ...
    def argmax(self, axis: Optional[int] = ...) -> ndarray[_DType]: ...
    def argmin(self, axis: Optional[int] = ...) -> ndarray[_DType]: ...
    # def argpartition(self, kth: Union[int, Sequence[int]], axis: Optional[int]=-1,
    #                  kind: str='introselect', order: _OrderType=None) -> ndarray[_DType]: ...
    def argsort(
        self, axis: Optional[int] = ..., kind: str = ..., order: Optional[_OrderType] = ...
    ) -> ndarray[_DType]: ...
    def astype(self, dtype: Type[_DType2], bool=...) -> ndarray[_DType2]: ...
    def byteswap(self, inplace: bool = ...) -> ndarray[_DType]: ...
    def choose(self, choices: Sequence[ndarray[_DType]], mode: str = ...) -> ndarray[_DType]: ...
    def clip(self, a_min: Any, a_max: Any) -> ndarray[_DType]: ...
    def compress(self, condition: Sequence[bool], axis: Optional[int] = ...) -> ndarray[_DType]: ...
    def conj(self) -> ndarray[_DType]: ...
    def conjugate(self) -> ndarray[_DType]: ...
    def copy(self, order: str = ...) -> ndarray[_DType]: ...
    def cumprod(self, axis: Optional[int] = ..., dtype: Optional[Any] = ...) -> ndarray[_DType]: ...
    def cumsum(
        self, axis: Optional[int] = ..., dtype: Optional[_DtypeType] = ...
    ) -> ndarray[_DType]: ...
    def diagonal(
        self, offset: int = ..., axis1: int = ..., axis2: int = ...
    ) -> ndarray[_DType]: ...
    def dot(self, b: ndarray[_DType]) -> ndarray[_DType]: ...
    def dump(self, file: str) -> None: ...
    def dumps(self) -> str: ...
    # def fill(self, value: _S) -> None: ...
    def flatten(self, order: str = ...) -> ndarray[_DType]: ...
    def getfield(self, dtype: _DtypeType, offset: int = ...) -> ndarray[_DType]: ...
    def item(self) -> _DType: ...
    def itemset(self, arg0: Union[int, Tuple[int, ...]], arg1: Optional[Any] = ...) -> None: ...
    def max(self) -> _DType: ...
    def mean(self) -> float: ...
    def min(self) -> _DType: ...
    def newbyteorder(self, new_order: str = ...) -> ndarray[_DType]: ...
    def nonzero(self) -> Tuple[ndarray[int64], ...]: ...
    def partition(
        self, kth: _AxesType, axis: int = ..., kind: str = ..., order: Optional[_OrderType] = ...
    ) -> None: ...
    def prod(
        self,
        axis: Optional[_AxesType] = ...,
        dtype: Optional[_DtypeType] = ...,
        keepdims: bool = ...,
    ) -> ndarray[_DType]: ...
    def ptp(self, axis: Optional[int] = ...) -> ndarray[_DType]: ...
    def put(self, ind: ndarray[_DType], v: ndarray[_DType], mode: str = ...) -> None: ...
    def ravel(self, order: str = ...) -> ndarray[_DType]: ...
    def repeat(
        self, repeats: Union[int, Sequence[int]], axis: Optional[int] = ...
    ) -> ndarray[_DType]: ...
    def reshape(self, newshape: _ShapeType, order: str = ...) -> ndarray[_DType]: ...
    def resize(self, new_shape: _ShapeType, refcheck: bool = ...) -> None: ...
    def round(self, decimals: int = ...) -> ndarray[_DType]: ...
    # def searchsorted(self, v: Union[_S, ndarray[_DType]], side: str='left',
    #                  sorter: ndarray[_DType]=None) -> ndarray[_DType]: ...
    def setfield(self, val: Any, dtype: _DtypeType, offset: int = ...) -> None: ...
    def setflags(
        self, write: Optional[bool] = ..., align: Optional[bool] = ..., uic: Optional[bool] = ...
    ) -> None: ...
    def sort(self, axis: int = ..., kind: str = ..., order: Optional[_OrderType] = ...) -> None: ...
    def squeeze(self, axis: Optional[_AxesType] = ...) -> ndarray[_DType]: ...
    def std(
        self,
        axis: Optional[_AxesType] = ...,
        dtype: Optional[_DtypeType] = ...,
        ddof: int = ...,
        keepdims: bool = ...,
    ) -> ndarray[_DType]: ...
    def sum(self) -> _DType: ...
    def swapaxes(self, axis1: int, axis2: int) -> ndarray[_DType]: ...
    def take(
        self, indices: Sequence[int], axis: Optional[int] = ..., mode: str = ...
    ) -> ndarray[_DType]: ...
    def tobytes(self, order: str = ...) -> bytes: ...
    def tofile(
        self,
        fid: object,
        sep: str = ...,  # TODO fix fid definition (There's a bug in mypy io's namespace https://github.com/python/mypy/issues/1462)
        format: str = ...,
    ) -> None: ...
    def tolist(self) -> List: ...
    def tostring(self, order: str = ...) -> bytes: ...
    def trace(
        self,
        offset: int = ...,
        axis1: int = ...,
        axis2: int = ...,
        dtype: Optional[_DtypeType] = ...,
    ) -> ndarray[_DType]: ...
    def transpose(self, axes: Optional[_AxesType] = ...) -> ndarray[_DType]: ...
    def var(
        self,
        axis: Optional[_AxesType] = ...,
        dtype: Optional[_DtypeType] = ...,
        ddof: int = ...,
        keepdims: bool = ...,
    ) -> ndarray[_DType]: ...
    def view(
        self,
        dtype: Optional[Union[_DtypeType, Type['ndarray[_DType]']]] = ...,
        type: Optional[type] = ...,
    ) -> ndarray[_DType]: ...
    #
    # Magic methods
    #
    def __abs__(self) -> ndarray[_DType]: ...
    def __add__(self, value: object) -> ndarray[_DType]: ...
    def __and__(self, value: object) -> ndarray[_DType]: ...
    def __array__(self, dtype: Optional[_DtypeType] = ...) -> ndarray[_DType]: ...
    def __array_prepare__(self, context: Optional[object] = ...) -> ndarray[_DType]: ...
    def __array_wrap__(self, context: Optional[object] = ...) -> ndarray[_DType]: ...
    def __bool__(self) -> bool: ...
    def __complex__(self) -> complex: ...
    def __contains__(self, key: object) -> bool: ...
    def __copy__(self) -> ndarray[_DType]: ...
    def __deepcopy__(self) -> ndarray[_DType]: ...
    def __delattr__(self, name: str) -> None: ...
    def __delitem__(self, key: str) -> None: ...
    def __dir__(self) -> List[str]: ...
    def __divmod__(self, value: object) -> Tuple[ndarray[_DType], ndarray[_DType]]: ...
    def __eq__(self, value: object) -> ndarray[bool_]: ...
    def __float__(self) -> float: ...
    def __floordiv__(self, value: object) -> ndarray[_DType]: ...
    def __ge__(self, value: object) -> ndarray[bool_]: ...
    def __getattribute__(self, name: str) -> Any: ...
    @overload
    def __getitem__(self, key: Union[int, Tuple[int, ...]]) -> _DType: ...
    @overload
    def __getitem__(
        self,
        key: Union[
            ndarray[bool_],
            slice,
            None,
            Tuple[int, Union[slice, ellipsis, None]],
            Tuple[Union[slice, ellipsis, None], int],
            Tuple[Union[ndarray[bool_], slice, Ellipsis, None], ...],
        ],
    ) -> ndarray[_DType]: ...
    def __gt__(self, value: object) -> ndarray[bool_]: ...
    def __iadd__(self, value: object) -> ndarray[_DType]: ...
    def __iand__(self, value: object) -> ndarray[bool_]: ...
    def __ifloordiv__(self, value: object) -> None: ...
    def __ilshift__(self, value: object) -> None: ...
    def __imatmul__(self, value: ndarray[_DType]) -> None: ...
    def __imod__(self, value: object) -> None: ...
    def __imul__(self, value: object) -> None: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> ndarray[_DType]: ...
    def __ior__(self, value: object) -> None: ...
    def __ipow__(self, value: object) -> None: ...
    def __irshift__(self, value: object) -> None: ...
    def __isub__(self, value: object) -> None: ...
    def __iter__(self) -> Iterator[_DType]: ...
    def __itruediv__(sel, value: object) -> None: ...
    def __ixor__(self, value: object) -> None: ...
    def __le__(self, value: object) -> ndarray[_DType]: ...
    def __len__(self) -> int: ...
    def __lshift__(self, value: object) -> ndarray[_DType]: ...
    def __lt__(self, value: object) -> ndarray[_DType]: ...
    def __matmul__(self, value: ndarray[_DType]) -> ndarray[_DType]: ...
    def __mod__(self, value: object) -> ndarray[_DType]: ...
    def __mul__(self, value: object) -> ndarray[_DType]: ...
    def __ne__(self, value: object) -> ndarray[_DType]: ...  # type: ignore
    def __neg__(self) -> ndarray[_DType]: ...
    def __or__(self, value: object) -> ndarray[_DType]: ...
    def __pos__(self) -> ndarray[_DType]: ...
    def __pow__(self, value: object) -> ndarray[_DType]: ...
    def __radd__(self, value: object) -> ndarray[_DType]: ...
    def __rand__(self, value: object) -> ndarray[_DType]: ...
    def __rdivmod__(self, value: object) -> Tuple[ndarray[_DType], ndarray[_DType]]: ...
    def __rfloordiv__(self, value: object) -> ndarray[_DType]: ...
    def __rlshift__(self, value: object) -> ndarray[_DType]: ...
    def __rmatmul__(self, value: object) -> ndarray[_DType]: ...
    def __rmod__(self, value: object) -> ndarray[_DType]: ...
    def __rmul__(self, value: object) -> ndarray[_DType]: ...
    def __ror__(self, value: object) -> ndarray[_DType]: ...
    def __rpow__(self, value: object) -> ndarray[_DType]: ...
    def __rrshift__(self, value: object) -> ndarray[_DType]: ...
    def __rshift__(self, value: object) -> ndarray[_DType]: ...
    def __rsub__(self, value: object) -> ndarray[_DType]: ...
    def __rtruediv__(self, value: object) -> ndarray[_DType]: ...
    def __rxor__(self, value: object) -> ndarray[_DType]: ...
    def __setattr__(self, name: str, value: Any) -> None: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def __str__(self) -> str: ...
    def __sub__(self, value: object) -> ndarray[_DType]: ...
    def __truediv__(sel, value: object) -> ndarray[_DType]: ...
    def __xor__(self, value: object) -> ndarray[_DType]: ...

# numpy has types that are more specific than int and float, but we treat them simply as aliases
# TODO: do this correctly (see commented out code below for hints)

##
## numpy's scalar hierarchy (http://docs.scipy.org/doc/numpy/reference/arrays.scalars.html#scalars)
##

# _Scalar = TypeVar('_Scalar')

# class generic(Generic[_Scalar]): ...
# class bool_(generic[bool]): ...
# class number(generic[_Scalar], Generic[_Scalar]): ...
# class integer(number[int]): ...
# class signedinteger(integer): ...
# class byte(signedinteger): ...
# class short(signedinteger): ...
# class intc(signedinteger): ...
# class int_(signedinteger): ...
# class longlong(signedinteger): ...
# class int8(signedinteger): ...
# class int16(signedinteger): ...
# class int32(signedinteger): ...
# class int64(signedinteger): ...
# class unsignedinteger(integer): ...
# class ubyte(unsignedinteger): ...
# class ushort(unsignedinteger): ...
# class uintc(unsignedinteger): ...
# class uint(unsignedinteger): ...
# class ulonglong(unsignedinteger): ...
# class uint8(signedinteger): ...
# class uint16(signedinteger): ...
# class uint32(signedinteger): ...
# class uint64(signedinteger): ...
# class inexact(number[float]): ...
# class floating(inexact): ...
# class half(floating): ...
# class single(floating): ...
# class float_(floating): ...
# class longfloat_(floating): ...
# class float16(floating): ...
# class float64(floating): ...
# class float128(floating): ...
# class complexfloating(inexact): ...
# class csingle(complexfloating): ...
# class complex_(complexfloating): ...
# class clongfloat(complexfloating): ...
# class complex64(complexfloating): ...
# class complex128(complexfloating): ...
# class complex256(complexfloating): ...
# class flexible(generic[_Scalar], Generic[_Scalar]): ...
# class character(flexible[str]): ...
# class str_(character): ...
# class unicode_(character): ...
# class void(flexible[None]): ...

#
# Array creation routines
#
@overload
def array(object: Union[_NestedList[Any], ndarray], dtype: Type[_DType]) -> ndarray[_DType]: ...
@overload
def array(object: Union[_NestedList[float], ndarray[_Float]]) -> ndarray[float64]: ...
@overload
def array(object: Union[_NestedList[int], ndarray[_Int]]) -> ndarray[int64]: ...
@overload
def arange(range_: int) -> ndarray[int64]: ...
@overload
def arange(range_: int, dtype: Type[_DType]) -> ndarray[_DType]: ...
def asarray(a: Any, dtype: Optional[_DtypeType] = ..., order: Optional[str] = ...) -> ndarray: ...
def ascontiguousarray(a: Any, dtype: Optional[_DtypeType] = ...) -> ndarray: ...
def copy(a: Any, order: Optional[str] = ...) -> ndarray: ...
def empty(shape: _ShapeType, dtype: _DtypeType = ..., order: str = ...) -> ndarray: ...
def empty_like(
    a: Any, dtype: Optional[Any] = ..., order: str = ..., subok: bool = ...
) -> ndarray: ...
def eye(N: int, M: Optional[int] = ..., k: int = ..., dtype: _DtypeType = ...) -> ndarray: ...
def full(
    shape: _ShapeType, fill_value: Any, dtype: Optional[_DtypeType] = ..., order: str = ...
) -> ndarray: ...
def full_like(
    a: Any, fill_value: Any, dtype: Optional[_DtypeType] = ..., order: str = ..., subok: bool = ...
) -> ndarray: ...

# def fromfunction(
#     function: Callable[..., _S], shape: _ShapeType, dtype: _DtypeType = float
# ) -> ndarray[_S]: ...
def fromiter(iterable: Iterator, dytpe: _DtypeType, count: int = ...) -> ndarray: ...
def fromstring(
    string: str, dtype: _DtypeType = ..., count: int = ..., sep: str = ...
) -> ndarray: ...
def identity(n: int, dtype: Optional[_DtypeType] = ...) -> ndarray: ...
@overload
def linspace(
    start: float, stop: float, num: int = ..., endpoint: bool = ...
) -> ndarray[float64]: ...
@overload
def linspace(
    start: float, stop: float, *, dtype: Type[_DType], num: int = ..., endpoint: bool = ...
) -> ndarray[_DType]: ...
def load(file: Union[Path, IO], encoding: str = ...) -> Dict[str, ndarray]: ...
def loadtxt(
    fname: Any,
    dtype: _DtypeType = ...,
    comments: Union[str, Sequence[str]] = ...,
    delimiter: Optional[str] = ...,
    converters: Optional[Dict[int, Callable[[Any], float]]] = ...,
    skiprows: int = ...,
    usecols: Optional[Sequence[int]] = ...,
    unpack: bool = ...,
    ndmin: int = ...,
) -> ndarray: ...
@overload
def ones(shape: _ShapeType, order: str = ...) -> ndarray[float64]: ...
@overload
def ones(shape: _ShapeType, dtype: Type[_DType] = ..., order: str = ...) -> ndarray[_DType]: ...
@overload
def ones_like(a: ndarray[_DType], subok: bool = ...) -> ndarray[_DType]: ...
@overload
def ones_like(a: ndarray, dtype: Type[_DType], subok: bool = ...) -> ndarray[_DType]: ...
@overload
def zeros(shape: _ShapeType, order: str = ...) -> ndarray[float64]: ...
@overload
def zeros(shape: _ShapeType, dtype: Type[_DType] = ..., order: str = ...) -> ndarray[_DType]: ...
@overload
def zeros_like(a: ndarray[_DType], order: str = ..., subok: bool = ...) -> ndarray[_DType]: ...
@overload
def zeros_like(a: ndarray, dtype: Type[_DType], subok: bool = ...) -> ndarray[_DType]: ...

#
# Array transformation routines
#
def astype(a: ndarray, dtype: Type[_DType]) -> ndarray[_DType]: ...
def abs(x: ndarray[_DType]) -> ndarray[_DType]: ...
def ceil(a: ndarray[_DType]) -> ndarray[_DType]: ...
def clip(a: ndarray[_DType], a_min: _DType, a_max: _DType) -> ndarray[_DType]: ...
def concatenate(
    an: Union[List[ndarray[_DType]], Tuple[ndarray[_DType], ...]], axis: _AxesType = ...
) -> (ndarray[_DType]): ...
def diag(a: ndarray[_DType]) -> ndarray[_DType]: ...
def divide(x1: ndarray, x2: ndarray) -> ndarray[float64]: ...
def exp(a: ndarray[_DType]) -> ndarray[_DType]: ...
def expand_dims(a: ndarray[_DType], axis: _AxesType) -> ndarray[_DType]: ...
def hstack(tup: Tuple[ndarray[_DType], ...]) -> ndarray[_DType]: ...
def log(a: ndarray[_DType]) -> ndarray[_DType]: ...
def logical_and(x1: ndarray[bool_], x2: ndarray[bool_]) -> ndarray[bool_]: ...
def matmul(a: ndarray[_DType], b: ndarray[_DType]) -> ndarray[_DType]: ...
def max(a: ndarray[_DType], axis: Optional[_AxesType], keepdims: bool = ...) -> ndarray[_DType]: ...
@overload
def mean(a: ndarray) -> float: ...
@overload
def mean(a: ndarray, axis: Optional[_AxesType], keepdims: bool = ...) -> ndarray[float64]: ...
def min(a: ndarray[_DType], axis: Optional[_AxesType], keepdims: bool = ...) -> ndarray[_DType]: ...
def nonzero(a: ndarray) -> Tuple[ndarray[_Int], ...]: ...
def power(x1: ndarray[_DType], x2: Union[_AnyNum, ndarray[_DType]]) -> ndarray[_DType]: ...
def ravel(a: ndarray[_DType]) -> ndarray[_DType]: ...
def reshape(a: ndarray[_DType], newshape: _ShapeType) -> ndarray[_DType]: ...
def sign(x: ndarray[_DType]) -> ndarray[_DType]: ...
def split(a: ndarray[_DType], split_dims: List[int]) -> List[ndarray[_DType]]: ...
def square(x: ndarray[_DType]) -> ndarray[_DType]: ...
def sqrt(a: ndarray) -> ndarray[float]: ...
def stack(arrays: List[ndarray[_DType]], axis: _AxesType = ...) -> ndarray[_DType]: ...
@overload
def std(a: ndarray[_Float], axis: Optional[_AxesType], keepdims: bool = ...) -> ndarray[_Float]: ...
@overload
def std(
    a: Union[ndarray[_Int], ndarray[bool_]], axis: Optional[_AxesType], keepdims: bool = ...
) -> ndarray[float64]: ...
@overload
def sum(a: ndarray[_DType]) -> _DType: ...
@overload
def sum(a: ndarray[_DType], axis: Optional[_AxesType], keepdims: bool = ...) -> ndarray[_DType]: ...
def take(a: ndarray[_DType], indices: ndarray[_Int], axis: _AxesType = ...) -> ndarray[_DType]: ...
def tile(a: ndarray[_DType], reps: Union[_NestedList[int], ndarray[_Int]]) -> ndarray[_DType]: ...
def trace(a: ndarray[_DType]) -> _DType: ...
def tril(m: ndarray[_DType], k: Optional[int] = ...) -> ndarray[_DType]: ...
def triu(m: ndarray[_DType], k: Optional[int] = ...) -> ndarray[_DType]: ...
def unique(a: ndarray[_DType]) -> ndarray[_DType]: ...
def where(condition: ndarray[bool_], x: ndarray[_DType], y: ndarray[_DType]) -> ndarray[_DType]: ...

#
# Saving methods
#
def savetxt(
    fname: str, X: ndarray, *, header: str = ..., delimiter: str = ..., newline: str = ...
) -> None: ...
def savez(file: Path, *args: ndarray, **kwds: ndarray) -> None: ...
def savez_compressed(file: Path, *args: ndarray, **kwds: ndarray) -> None: ...

#
# weird classes
#
class matrix:
    def __init__(self, data: Union[List, str], dtype: _DtypeType = ..., copy: bool = ...): ...
    def reshape(self, shape: _ShapeType) -> matrix: ...

#
# Specific values
#
inf: float
nan: float
