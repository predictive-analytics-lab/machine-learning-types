from typing import List, Tuple, Type, Union, overload
from typing_extensions import Literal
import numpy as _np

from .indexes import Index

_Num = TypeVar('_Num', int, float, bool)

class Series:
    # magic methods
    def __and__(self, other: Series) -> Series: ...
    def __eq__(self, other: object) -> Series: ...  # type: ignore
    @overload
    def __getitem__(self, idx: Union[List[str], Index[int], Series, slice]) -> Series: ...
    @overload
    def __getitem__(self, idx: int) -> float: ...
    def __truediv__(self, other: object) -> Series: ...
    #
    # properties
    @property
    def index(self) -> Index[int]: ...
    @property
    def shape(self) -> Tuple[int, ...]: ...
    @property
    def values(self) -> _np.ndarray: ...
    #
    # methods
    def all(self, axis: int = ..., bool_only: bool = ...) -> bool: ...
    def corr(
        self, other: Series, method: Literal["pearson", "kendall", "spearman"] = ...
    ) -> float: ...
    def count(self) -> int: ...
    def max(self) -> float: ...
    def mean(self) -> float: ...
    def min(self) -> float: ...
    def nunique(self) -> int: ...
    def replace(self, to_replace: int, value: int, inplace: bool) -> None: ...
    def std(self) -> float: ...
    @overload
    def to_numpy(self) -> _np.ndarray: ...
    @overload
    def to_numpy(self, dtype: Type[_Num]) -> _np.ndarray[_Num]: ...
    def unique(self) -> List[float]: ...
    def value_counts(self) -> Series: ...
